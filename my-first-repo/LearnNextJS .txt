###ğ—–ğ—¼ğ—ºğ—½ğ—®ğ—¿ğ—¶ğ˜€ğ—¼ğ—» ğ—¼ğ—³ **ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€** ğ—®ğ—»ğ—± **ğ—¥ğ—²ğ—®ğ—°ğ˜.ğ—·ğ˜€**:


## **ğ™ğ™ğ™¢ğ™ğ™¡ğ™–ğ™§ğ™ğ™©ğ™ğ™šğ™¨ ğ˜½ğ™šğ™©ğ™¬ğ™šğ™šğ™£ ğ™‰ğ™šğ™­ğ™©.ğ™Ÿğ™¨ ğ™–ğ™£ğ™™ ğ™ğ™šğ™–ğ™˜ğ™©.ğ™Ÿğ™¨**

1. **Built on React Library**:
   - Next.js is a framework built on top of React.js, so it uses React's core principles, such as components, props, and state.

2. **Component-Based Architecture**:
   - Both Next.js and React.js rely on reusable components for building user interfaces.

3. **JSX Syntax**:
   - Both use JSX (JavaScript XML) for templating, allowing developers to write HTML-like code directly in JavaScript.

4. **Client-Side Rendering**:
   - Both support client-side rendering (CSR), where JavaScript runs on the client to render the user interface.

5. **Tooling**:
   - Both use popular developer tools like `npm`/`yarn` for package management and `ESLint` for code quality.

---

### **ğ˜¿ğ™ğ™›ğ™›ğ™šğ™§ğ™šğ™£ğ™˜ğ™šğ™¨ ğ˜½ğ™šğ™©ğ™¬ğ™šğ™šğ™£ ğ™‰ğ™šğ™­ğ™©.ğ™Ÿğ™¨ ğ™–ğ™£ğ™™ ğ™ğ™šğ™–ğ™˜ğ™©.ğ™Ÿğ™¨**

| Feature                        | **Next.js**                                     | **React.js**                                  |
|--------------------------------|------------------------------------------------|-----------------------------------------------|
| **Type**                       | Framework                                      | Library                                       |
| **Routing**                    | Built-in file-based routing system.            | Needs external libraries like `react-router`. |
| **Rendering Options**          | Supports SSR, SSG, CSR, and ISR.               | Only supports CSR natively.                   |
| **Performance**                | Optimized for server-side rendering and SEO.   | Depends on external tools for optimization.   |
| **SEO**                        | Better SEO support with SSR and SSG.           | SEO is challenging due to CSR limitations.    |
| **Configuration**              | Comes pre-configured with a robust setup.      | Requires manual setup and configurations.     |
| **API Routes**                 | Built-in API routing to create backend APIs.   | No built-in API handling; needs external tools like `Express`. |
| **Build Time**                 | Slower than React due to SSR and pre-rendering.| Faster due to CSR only.                       |
| **Flexibility**                | Opinionated (imposes structure).               | Unopinionated (fully customizable).           |
| **Learning Curve**             | Steeper due to its additional features.        | Easier for beginners.                         |
| **Static Site Generation (SSG)**| Supports pre-rendering static pages at build time. | Not available natively.                       |

---

### **When to Use Next.js**
- SEO is a priority (e.g., blogs, e-commerce sites).
- Need server-side rendering (SSR) or static site generation (SSG).
- Want to build full-stack applications with integrated APIs.
- Prefer a framework with built-in features like routing and optimizations.

### **When to Use React.js**
- Building simple or highly interactive client-side applications.
- Require more control and flexibility over project structure.
- Already using a custom backend or routing system.

-----------------------------------------



### ğ‹ğğšğ«ğ§ ğğğ±ğ­.ğ£ğ¬

Next.js uses the React.js library, so we can say that Next.js is a framework of React.js. This means all React.js code can also be used in Next.js.

-----------------------------------------

## 1. ğ‘«ğ’Šğ’‡ğ’‡ğ’†ğ’“ğ’†ğ’ğ’„ğ’† ğ‘©ğ’†ğ’•ğ’˜ğ’†ğ’†ğ’ ğ‘µğ’ğ’“ğ’ğ’‚ğ’ ğ‘­ğ’–ğ’ğ’„ğ’•ğ’Šğ’ğ’ ğ’‚ğ’ğ’… ğ‘¬ğ’™ğ’‘ğ’ğ’“ğ’• ğ‘«ğ’†ğ’‡ğ’‚ğ’–ğ’ğ’• ğ‘­ğ’–ğ’ğ’„ğ’•ğ’Šğ’ğ’:
- When we use `export default`, we can import a function without using braces `{}`.  
  Example:  
  ```javascript
  import MyFunction from './MyFile';
  ```
- When we do not use `export default`, we must use braces `{}` to import it.  
  Example:  
  ```javascript
  import { MyFunction } from './MyFile';
  ```

-----------------------------------------

## ğŸ. ğ‚ğ¨ğ¦ğ©ğ¨ğ§ğğ§ğ­ğ¬

Components are reusable pieces of code. They work similarly to functions in programming languages like PHP or JavaScript, allowing us to reuse them wherever needed.

### ğŸ®.ğŸ­. ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—² ğ—•ğ—²ğ˜ğ˜„ğ—²ğ—²ğ—» ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€ ğ—®ğ—»ğ—± ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜ğ˜€
1. Functions:  
   - It is not mandatory for a function to return a value.  
   - A functionâ€™s name can start with a lowercase letter.  
2. Components:  
   - Components always include a `return` statement.  
   - In React.js or Next.js, component names must start with a capital letter.

-----------------------------------------

## ğŸ‘. ğğ«ğ¨ğ©ğ¬

Data can be passed between components using props, just like in React.js.

-----------------------------------------

## ğŸ°. ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—² ğ—•ğ—²ğ˜ğ˜„ğ—²ğ—²ğ—» ğ—ğ—®ğ˜ƒğ—®ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ ğ—®ğ—»ğ—± ğ—§ğ˜†ğ—½ğ—²ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜

1. JavaScript:  
   - It performs automatic type conversion; no need to explicitly declare data types (e.g., `int`, `string`, or `boolean`).  
2. TypeScript:  
   - Data types must be explicitly declared when defining variables.

-----------------------------------------

## ğŸ°. ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—² ğ—•ğ—²ğ˜ğ˜„ğ—²ğ—²ğ—» ğ—ğ—®ğ˜ƒğ—®ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ ğ—®ğ—»ğ—± ğ—§ğ˜†ğ—½ğ—²ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜

No, the browser cannot directly read TypeScript. The code is first transpiled from TypeScript to JavaScript, and then the browser can execute it.

-----------------------------------------

## ğŸ². ğ—¦ğ—²ğ—¿ğ˜ƒğ—²ğ—¿-ğ—¦ğ—¶ğ—±ğ—² ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ğ—¶ğ—»ğ—´ ğ˜ƒğ˜€. ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜-ğ—¦ğ—¶ğ—±ğ—² ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ğ—¶ğ—»ğ—´

1. Server-Side Scripting:  
   - Code is executed on the server, generating a response sent to the client.  
   - Example: Validating user data by querying a database and returning results (e.g., PHP, Java).  

2. Client-Side Scripting:  
   - Code is executed directly in the browser.  
   - Example: Validating form fields using JavaScript or jQuery.  

### 6.1. SSR (Server-Side Rendering) vs. CSR (Client-Side Rendering)
- SSR:  
  - Generates full HTML on the server and sends it to the client.  
  - JavaScript is executed on the client for interactive features like button clicks or form submissions.  
- CSR:  
  - Generates HTML on the client using JavaScript.  
  - The user sees a blank page until JavaScript loads and renders the content.

-----------------------------------------

## ğŸ³. ğ—˜ğ˜ƒğ—²ğ—»ğ˜ğ˜€, ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€, ğ—®ğ—»ğ—± ğ—¦ğ˜ğ—®ğ˜ğ—²

### 7.1. State
1. State is a container used within components to store data or information. It cannot be accessed outside the component.  
2. To pass state data between components, it must be passed as props, not as the state itself.  

### ğ—¡ğ—¼ğ˜ğ—²:
- State updates trigger a component re-render, updating its data wherever used.  
- Variables do not trigger re-renders when updated.

-----------------------------------------

## ğŸ´. ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—² ğ—•ğ—²ğ˜ğ˜„ğ—²ğ—²ğ—» ğ—–ğ—®ğ—¹ğ—¹ğ—¶ğ—»ğ—´ ğ—® ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜ ğ—œğ—»ğ˜€ğ—¶ğ—±ğ—² ğ—”ğ—»ğ—¼ğ˜ğ—µğ—²ğ—¿ ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜ ğ˜ƒğ˜€. ğ—–ğ—®ğ—¹ğ—¹ğ—¶ğ—»ğ—´ ğ—œğ˜ ğ—®ğ˜€ ğ—® ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»

1. Using `<Component />` in JSX treats it as a React component, allowing React to manage its lifecycle and state.  
2. Using `{Component()}` calls the function directly, rendering its return value. However, it does not have access to React's lifecycle or state management.

-----------------------------------------

## ğŸµ. ğ—™ğ—¶ğ—¹ğ—² ğ—®ğ—»ğ—± ğ—™ğ—¼ğ—¹ğ—±ğ—²ğ—¿ ğ—¦ğ˜ğ—¿ğ˜‚ğ—°ğ˜ğ˜‚ğ—¿ğ—²ğ˜€

### Key Files:
1. `package.json`:  
   - Contains commands, dependencies, and project details.  
   - Used by NPM to install dependencies and run commands.  

2. `next.config.js`:  
   - Used for Next.js configuration (e.g., setting environment variables, base paths, or custom ESLint rules).  

3. `jsconfig.json` (or `tsconfig.json` for TypeScript):  
   - Configures JavaScript/TypeScript settings (e.g., CDN, ECMAScript version, or file paths).

-----------------------------------------

##ğ—›ğ—¼ğ˜„ ğ˜ğ—¼ ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—² ğ—¹ğ—®ğ˜†ğ—¼ğ˜‚ğ˜ğ˜€ ğ—®ğ—»ğ—± ğ—½ğ—®ğ—´ğ—²ğ˜€:

Next.js uses file-system based routing, meaning you can use folders and files to define routes.

A Folder name matches the routes name .
Page.js should be present in every folder.



## ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—» ğ—³ğ—¼ğ—¿ ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—¶ğ—»ğ—´ ğ—¿ğ—¼ğ˜‚ğ—²ğ˜ğ˜€ ğ—¶ğ—» ğ—¡ğ—˜ğ—«ğ—§ ğ—ğ˜€?

=>Inside the src folder  we have folderName=RoutesName which will include page.tsx file 

# DO we need to Install any external package for Next Js Routing?
=> No in Next there  is no need but it isnee din React Js as in Next Js it has its own Routing 
---------------------------------------
##ğ—›ğ—¼ğ˜„ ğ˜ğ—¼ ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—² ğ—¹ğ—®ğ˜†ğ—¼ğ˜‚ğ˜ğ˜€ ğ—®ğ—»ğ—± ğ—½ğ—®ğ—´ğ—²ğ˜€:
Next.js uses file-system based routing, meaning you can use folders and files to define routes.

A Folder name matches the route's name.
Page.js should be present in every folder.

##What is the Pattern for creating routes in Next.js?
=>Inside the src folder, we have folderName = RouteName, which will include the page.tsx file.

##Do we need to Install any external packages for Next.js Routing?
=>No, in Next.js there is no need, but it is needed in React.js as Next.js has its own routing.

-----------------------------------------
###ğ—Ÿğ—¶ğ—»ğ—¸ğ—¶ğ—»ğ—´ ğ—®ğ—»ğ—± ğ—¡ğ—®ğ˜ƒğ—¶ğ—´ğ—®ğ˜ğ—¶ğ—¼ğ—»:
1. Linking:
	=>Linking is basically when we move from one screen to another using an anchor tag.
	=>It is used for actions that won't affect the website at all.
	=>Done using <Link href=""></Link>

2. Navigation:
	=>Navigation is the same as above, but here we move using a button tag.
	=>It is used for actions that affect the website's frontend or backend.
	=>In order to use it, we have to use the useRouter hook from next/navigation, so we have to make sure the component is Client-Side.
	=>Done using <button></button>

ğ—¡ğ—¼ğ˜ğ—²: Unlike in React.js, where we need to import any component to use it, in Next.js, there is no need for this as it uses file-system-based routing. Therefore, it automatically imports it.

##ğ—¡ğ—²ğ˜€ğ˜ğ—²ğ—± ğ—¥ğ—¼ğ˜‚ğ˜ğ—¶ğ—»ğ—´:
source/folder/subfolder
-----------------------------------------
ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—» ğ—Ÿğ—®ğ˜†ğ—¼ğ˜‚ğ˜:

=>ğ—Ÿğ—®ğ˜†ğ—¼ğ˜‚ğ˜.ğ—·ğ˜€ : It Provide's comman areas to its child rouets/children Components 
In our NEXTJS Apllication, there RootLayout which is available for every page whatever written inside it will be available for all.
Example:export default function Layout({children}){
return(
    <div>
        {children}
    </div>
)
}

## ğ—–ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—Ÿğ—®ğ˜†ğ—¼ğ˜‚ğ˜:
What is Conditional Layout?
==>A conditional layout refers to dynamically rendering different layouts for your pages or components based on specific conditions. In a web application, a    layout typically consists of shared UI elements like headers, footers, sidebars, or navigation menus, which surround the main content of a page.

	In the context of Next.js, a conditional layout means deciding which layout to render depending on factors such as:

	The route or page being accessed.
	User authentication or roles (e.g., admin vs. regular user).
	Device type (mobile vs. desktop).
	The application's state (e.g., logged-in vs. logged-out).
		
#ğ—•ğ—²ğ—»ğ—²ğ—³ğ—¶ğ˜ğ˜€ ğ—¼ğ—³ ğ—–ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—Ÿğ—®ğ˜†ğ—¼ğ˜‚ğ˜ğ˜€:
A conditional layout allows your application to:

=>Dynamically render different layouts for specific pages or sections.
=>Customize the user experience based on the context (route, user role, etc.).
=>To implement this in Next.js, you can use the usePathname() hook from next/navigation.

  Here we wil use "usePathname()" from next/navigation


-----------------------------------------

##ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¥ğ—¼ğ˜‚ğ˜ğ—²ğ˜€**:

### **ğ‘¾ğ’‰ğ’‚ğ’• ğ’Šğ’” ğ‘«ğ’šğ’ğ’‚ğ’ğ’Šğ’„ ğ‘¹ğ’ğ’–ğ’•ğ’Šğ’ğ’ˆ ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”?**

In **Next.js**, **dynamic routing** allows you to create routes (URLs) that are not hardcoded but instead dynamically generated based on data or variables. This is particularly useful when building applications where the route structure depends on external data (e.g., user profiles, product pages, blog posts, etc.).

---

### **ğ—¦ğ˜ğ—®ğ˜ğ—¶ğ—° ğ˜ƒğ˜€ ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¥ğ—¼ğ˜‚ğ˜ğ—²ğ˜€**

1. **Static Route**:
   - A route with a fixed path.
   - Example: `/about`, `/contact`.

2. **Dynamic Route**:
   - A route with a path that changes based on a parameter or variable.
   - Example: `/product/[id]`, `/user/[username]`.

---

### **ğ‘¯ğ’ğ’˜ ğ‘«ğ’šğ’ğ’‚ğ’ğ’Šğ’„ ğ‘¹ğ’ğ’–ğ’•ğ’Šğ’ğ’ˆ ğ‘¾ğ’ğ’“ğ’Œğ’” ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”**

1. **Dynamic Segments**:
   Use square brackets (`[ ]`) in your `pages/` directory to define dynamic routes.
   
   Example:
   ```
   pages/
   â”œâ”€â”€ index.js
   â”œâ”€â”€ product/
   â”‚   â”œâ”€â”€ [id].js
   ```
   - Here, `[id].js` is a **dynamic route**. It can match URLs like `/product/1`, `/product/42`, etc.

2. **Fetching the Dynamic Parameter**:
   Use the **`useRouter`** hook or the `getStaticProps`/`getServerSideProps` context to fetch the dynamic parameter.

---

### **Example of Dynamic Routing**

#### **Folder Structure**
```
pages/
â”œâ”€â”€ index.js             // Home page
â”œâ”€â”€ blog/
â”‚   â”œâ”€â”€ [slug].js        // Dynamic route for blog posts
```

#### **Code for a Dynamic Blog Route**
```jsx
// pages/blog/[slug].js
import { useRouter } from "next/router";

export default function BlogPost() {
  const router = useRouter();
  const { slug } = router.query; // Dynamic parameter (slug)

  return (
    <div>
      <h1>Blog Post: {slug}</h1>
      <p>This is the blog post content for {slug}.</p>
    </div>
  );
}
```

- **Access URL**: `/blog/hello-world` â†’ `slug = "hello-world"`

---

### **ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¥ğ—¼ğ˜‚ğ˜ğ—¶ğ—»ğ—´ ğ˜„ğ—¶ğ˜ğ—µ ğ——ğ—®ğ˜ğ—® ğ—™ğ—²ğ˜ğ—°ğ—µğ—¶ğ—»ğ—´**

To render data dynamically, use `getStaticPaths` and `getStaticProps` (or `getServerSideProps`).

#### **Dynamic Route with `getStaticPaths` and `getStaticProps`**
```jsx
// pages/blog/[slug].js
export async function getStaticPaths() {
  // Fetch all possible slugs (e.g., from an API or database)
  const posts = await fetch("https://example.com/api/posts").then((res) =>
    res.json()
  );

  // Define paths for dynamic routes
  const paths = posts.map((post) => ({
    params: { slug: post.slug },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  // Fetch data for a specific blog post using the dynamic slug
  const post = await fetch(
    `https://example.com/api/posts/${params.slug}`
  ).then((res) => res.json());

  return {
    props: { post },
  };
}

export default function BlogPost({ post }) {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  );
}
```

---

### **ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ—°ğ—²ğ—± ğ—™ğ—²ğ—®ğ˜ğ˜‚ğ—¿ğ—²ğ˜€ ğ—¼ğ—³ ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¥ğ—¼ğ˜‚ğ˜ğ—¶ğ—»ğ—´**

1. **Catch-All Routes**:
   - Use `[...param].js` to match multiple segments.
   - Example: `/blog/[...slug].js` matches `/blog/a`, `/blog/a/b`, `/blog/a/b/c`.

   ```jsx
   // pages/blog/[...slug].js
   import { useRouter } from "next/router";

   export default function BlogPost() {
     const router = useRouter();
     const { slug } = router.query; // Array of segments

     return <h1>Path: {slug.join("/")}</h1>;
   }
   ```

2. **Optional Catch-All Routes**:
   - Use `[[...param]].js` to make segments optional.
   - Example: `/blog/[[...slug]].js` matches `/blog`, `/blog/a`, `/blog/a/b`.

---

### **ğ—•ğ—²ğ—»ğ—²ğ—³ğ—¶ğ˜ğ˜€ ğ—¼ğ—³ ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¥ğ—¼ğ˜‚ğ˜ğ—¶ğ—»ğ—´**
1. **Scalability**:
   - Add new routes dynamically without updating code.
2. **SEO-Friendly**:
   - Use `getStaticProps` and `getStaticPaths` to pre-render pages with unique metadata for each route.
3. **Flexibility**:
   - Easily handle complex URL structures like `/product/[category]/[id]`.

---------------------------------------------------

### ğ—¥ğ—¼ğ˜‚ğ˜ğ—¶ğ—»ğ—´ ğ—¦ğ—²ğ—´ğ—ºğ—²ğ—»ğ˜ğ˜€ ğ—œğ—» ğ—¡ğ—²ğ˜…ğ˜ ğ—ğ—¦:


##What are segments  of the Routes?
=>In Next.js, segments refer to the parts of a URL path that help define the structure and dynamic nature of a route. These segments are represented by folders or files in the pages directory, which map directly to the URL structure of your application.

##ğ—§ğ˜†ğ—½ğ—²ğ˜€ ğ—¼ğ—³ ğ—¥ğ—¼ğ˜‚ğ˜ğ—² ğ—¦ğ—²ğ—´ğ—ºğ—²ğ—»ğ˜ğ˜€:

=>ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘ºğ’†ğ’ˆğ’ğ’†ğ’ğ’•ğ’”:
	Static segments represent fixed parts of the URL that donâ€™t change.
	They are created using regular folder or file names in the pages directory.
Example:

pages/
|-- about.js
|-- contact.js
/about â†’ Maps to about.js.
/contact â†’ Maps to contact.js.
=>ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¦ğ—²ğ—´ğ—ºğ—²ğ—»ğ˜ğ˜€:
  Dynamic segments are placeholders for variable parts of the URL.
  Represented by square brackets ([ ]) in the file or folder name.
Example:

pages/
|-- product/
    |-- [id].js
/product/1 â†’ Maps to id = 1.
/product/42 â†’ Maps to id = 42.
=>Accessing Dynamic Segments:
 Use useRouter from next/router or the params object in getStaticProps/getServerSideProps.




##ğ—–ğ—®ğ˜ğ—°ğ—µ-ğ—®ğ—¹ğ—¹ ğ—¦ğ—²ğ—´ğ—ºğ—²ğ—»ğ˜ğ˜€ ğ—¢ğ—³ ğ—¥ğ—¼ğ˜‚ğ˜ğ—²ğ˜€:
  In Next.js, catch-all routes allow you to match an arbitrary number of segments in a single route. This is particularly useful when you want a dynamic route to handle multiple nested levels of paths.
  
#ğ‘²ğ’†ğ’š ğ‘·ğ’ğ’Šğ’ğ’•ğ’” ğ’•ğ’ ğ‘¹ğ’†ğ’ğ’†ğ’ğ’ƒğ’†ğ’“:
	Catch-all route: [...slug] matches one or more segments.
	Optional catch-all route: [[...slug]] matches zero or more segments.
	Use the slug array to access the segments.
	Be mindful of route precedence; catch-all routes should not conflict with more specific dynamic or static routes.
	Whenever we are not aware that how many segments would be there in thsi case we can use catch-all segments

---------------------------------------
### ğŸ°ğŸ¬ğŸ° ğ—£ğ—®ğ—´ğ—²ğ˜€ ğ—¶ğ—» ğ—¡ğ—˜ğ—«ğ—§ğ—ğ—¦:

In Next.js, you can create custom 404 pages to display when a user tries to access a route that doesn't exist. 
Here's everything you need to know about creating and customizing 404 pages in Next.js.

##Default 404 Page
 If you don't create a custom 404 page, Next.js will automatically display a default 404 page when a route is not found.

##Custom 404 Page
 =>To create your custom 404 page, follow these steps:

	#File Location
	->Place the custom 404 page in the pages directory (if you're using the pages directory).
	->Place it in the app directory as 404.jsx or 404.tsx (if you're using the app directory).


##For Global 404 Page:
=>We have to place 'not-found.js'  file inside app directory.


## For Local 404 Page:
We have make a folder the way we have created for the catch-all segments then we can make our page.tsx with the content we hav tos hwo for this.


Note: 
Generally in a website there is only one 404 page is there which is global but we have make logically if we want  by making use of catch all segments concept. 



--------------------------------------------------------------------------------------
## ğ— ğ—¶ğ—±ğ—±ğ—¹ğ—²ğ—ªğ—®ğ—¿ğ—²  ğ—œğ—» ğ—¡ğ—²ğ˜…ğ˜ğ—ğ˜€ :

What is MiddleWare In Next Js Routing ?
=>In Next.js, **middleware** is a feature that allows you to run custom logic before a request is completed. Middleware sits between the request and the response, enabling you to modify the request or response, perform redirects, authenticate users, and more before rendering a page.

### Key Features of Middleware in Next.js:
1. **Custom Logic Execution**: Middleware enables you to run code before a request is processed.
2. **Routing Control**: You can rewrite, redirect, or modify the response based on conditions.
3. **Edge Runtime**: Middleware runs on the Edge Runtime, meaning it is lightweight and has low latency.
4. **Request-Based**: Middleware works on a per-request basis, allowing granular control over behavior.

---

### Where Middleware is Used:
1. **Authentication**: Check if a user is logged in and redirect them to a login page if not.
2. **Localization**: Dynamically route users to a localized version of the site based on their location or preferences.
3. **Feature Flagging**: Serve different content or enable features based on user roles or other conditions.
4. **Dynamic Rewrites**: Change the path or query parameters dynamically before rendering a page.

---

### Example Middleware Code:
To create middleware in Next.js, you use the `middleware.js` file in the root of your project (inside src folder) or in a directory under `pages/src`.

```javascript
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const { pathname } = request.nextUrl;

  // Example: Redirect to login if accessing a protected page
  if (pathname.startsWith('/dashboard') && !request.cookies.get('authToken')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Example: Add a custom header to the request
  const response = NextResponse.next();
  response.headers.set('X-Custom-Header', 'My Middleware Header');
  return response;
}

// Specify routes to include or exclude
export const config = {
  matcher: ['/dashboard/:path*'], // Apply middleware to specific paths
};
```

---
Note: This middleware code is executed on the server side so if we made any console.log in middware.js  file  only not 'tsx' or 'jsx' is supported here  that wil not be visible.

### Key Objects:
- **`request`**: Contains information about the incoming HTTP request, such as headers, cookies, and URL.
- **`NextResponse`**: Provides utility methods like `redirect()`, `rewrite()`, or `next()` to control the request flow.

---

### Matcher Configuration:
You can control which routes the middleware applies to by defining a `matcher` in the `config` export.

Example:
```javascript
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
};
```

---

### Key Benefits:
1. **Serverless by Default**: Middleware is executed on the edge, making it highly efficient.
2. **Improved User Experience**: By redirecting, rewriting, or adding headers dynamically, you can improve the user experience.
3. **Granular Control**: Middleware lets you target specific routes and customize behavior.


--------------------------------------------------------------------------------------

### **ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€**   ğŸš€

 
 => **What is Rendering?**  
Rendering refers to the process of converting React components into HTML that users can see in the browser. In **Next.js**, rendering determines how and when a page's content is generated.  

Next.js provides multiple rendering strategies to optimize performance and SEO.  

---

## Types Of Rendering Environments :
=>Client-Side Environment: Inside Client environment our code comes on browser and then HTML is converted(rendered) from our code  
=>Server-Side Environment:


## **ğ—§ğ˜†ğ—½ğ—²ğ˜€ ğ—¼ğ—³ ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€**  

### **ğŸ­ï¸âƒ£ ğ—£ğ—¿ğ—²-ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ (ğ—¥ğ—²ğ—°ğ—¼ğ—ºğ—ºğ—²ğ—»ğ—±ğ—²ğ—±)**
Pre-rendering means that Next.js generates the HTML for a page **before** it is sent to the client, improving performance and SEO.  
 or
Generate the HTML in advance on the server side .

**ğ™ğ™®ğ™¥ğ™šğ™¨ ğ™¤ğ™› ğ™‹ğ™§ğ™š-ğ™ğ™šğ™£ğ™™ğ™šğ™§ğ™ğ™£ğ™œ:**  

#### âœ… **ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘®ğ’†ğ’ğ’†ğ’“ğ’‚ğ’•ğ’Šğ’ğ’ (ğ‘ºğ‘ºğ‘®) â€“ ğ‘©ğ’†ğ’”ğ’• ğ’‡ğ’ğ’“ ğ‘·ğ’†ğ’“ğ’‡ğ’ğ’“ğ’ğ’‚ğ’ğ’„ğ’† & ğ‘ºğ‘¬ğ‘¶**  
- The page is generated **at build time** and reused for every request.  
- Itâ€™s **super fast** since the HTML is pre-built and cached.  
- **Use when:** Content doesnâ€™t change often (e.g., blogs, product pages).  
- In this both the 'Server and Client' Components  (page) can be prerendered on the server at the build time.

ğŸ”¹ **Example (SSG with `getStaticProps`)**  
```javascript
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data.title}</div>;
}
```

ğŸ“Œ **Generated once at build time, served to all users.**

---

#### âœ… **ğ‘ºğ’†ğ’“ğ’—ğ’†ğ’“-ğ‘ºğ’Šğ’…ğ’† ğ‘¹ğ’†ğ’ğ’…ğ’†ğ’“ğ’Šğ’ğ’ˆ (ğ‘ºğ‘ºğ‘¹) â€“ ğ‘®ğ’ğ’ğ’… ğ’‡ğ’ğ’“ ğ‘ºğ‘¬ğ‘¶ & ğ‘¹ğ’†ğ’‚ğ’-ğ’•ğ’Šğ’ğ’† ğ‘«ğ’‚ğ’•ğ’‚**  
- The page is generated **on each request** (not at build time).(generate on dynamic time)  
- Ideal for **dynamic content** that must always be fresh (e.g., user dashboards, stock prices).  
- **Use when:** Content updates frequently or is user-specific.  

ğŸ”¹ **Example (SSR with `getServerSideProps`)**  
```javascript
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data.title}</div>;
}
```

ğŸ“Œ **Generated every time a request is made.**

---

### **ğŸ®ï¸âƒ£ ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜-ğ—¦ğ—¶ğ—±ğ—² ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ (ğ—–ğ—¦ğ—¥) â€“ ğ—™ğ—¼ğ—¿ ğ—œğ—»ğ˜ğ—²ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—¶ğ˜ğ˜†**  
- The page is rendered **in the browser** after loading.  
- Content is fetched **after the initial load**, making it slower for SEO.  
- **Use when:** SEO is not a concern, but interactivity is needed (e.g., dashboards, chat apps).  

ğŸ”¹ **Example (CSR using `useEffect`)**  
```javascript
import { useState, useEffect } from 'react';

export default function Page() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://api.example.com/data')
      .then((res) => res.json())
      .then((data) => setData(data));
  }, []);

  return <div>{data ? data.title : 'Loading...'}</div>;
}
```

ğŸ“Œ **Data is fetched on the client side after the page loads.**

------
### **3ï¸âƒ£ ğ‘°ğ’ğ’„ğ’“ğ’†ğ’ğ’†ğ’ğ’•ğ’‚ğ’ ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘¹ğ’†ğ’ˆğ’†ğ’ğ’†ğ’“ğ’‚ğ’•ğ’Šğ’ğ’ (ğ‘°ğ‘ºğ‘¹) â€“ ğ‘©ğ’†ğ’”ğ’• ğ’ğ’‡ ğ‘©ğ’ğ’•ğ’‰ ğ‘¾ğ’ğ’“ğ’ğ’…ğ’”** 

 =>ISR allows **updating static pages** without rebuilding the entire site. This combines the speed of **Static Site Generation (SSG)** with the flexibility of **Server-Side Rendering (SSR)**.  

### **ğŸ”¹ How ISR Works:**  
1. The page is **pre-built at build time** (like SSG).  
2. When a request is made, the old static page is served immediately.  
3. **In the background**, Next.js regenerates the page based on a `revalidate` interval.  
4. The new version replaces the old one after regeneration.  

### **âœ… Advantages of ISR:**  
âœ”ï¸ **Fast performance** (serves pre-rendered pages).  
âœ”ï¸ **Fresh data** without rebuilding the entire site.  
âœ”ï¸ **Great for SEO** (full HTML available).  
âœ”ï¸ **Efficient** (only regenerates necessary pages).  

### **ğŸ”¹ Example of ISR in Next.js:**  
```javascript
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return {
    props: { data },
    revalidate: 10, // Regenerate the page every 10 seconds
  };
}

export default function Page({ data }) {
  return <div>{data.title}</div>;
}
```
ğŸ“Œ **Old content is served instantly, and the new version is updated in the background every 10 seconds.**  

### **ğŸ”¹ When to Use ISR?**  

âœ… Blogs, News, E-commerce, Product Listings (where content updates occasionally).  

ğŸš€ **ISR is the perfect balance between speed and freshness!**

### **3ï¸âƒ£ ğ‘°ğ’ğ’„ğ’“ğ’†ğ’ğ’†ğ’ğ’•ğ’‚ğ’ ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘¹ğ’†ğ’ˆğ’†ğ’ğ’†ğ’“ğ’‚ğ’•ğ’Šğ’ğ’ (ğ‘°ğ‘ºğ‘¹) â€“ in short: 
- Allows **updating static pages** without a full rebuild.  
- Next.js regenerates the page **in the background** while serving old content.  
- **Use when:** You need pre-rendering but with occasional updates (e.g., news, product listings).  

ğŸ”¹ **Example (ISR with `revalidate`)**  
```javascript
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return {
    props: { data },
    revalidate: 10, // Rebuild the page every 10 seconds
  };
}
```

ğŸ“Œ **Combines the speed of SSG with the flexibility of SSR.**



----------

### **ğŸš€ Which Rendering Method to Choose?**  
| Feature | **SSG** | **SSR** | **CSR** | **ISR** |
|---------|--------|--------|--------|--------|
| Speed | ğŸš€ğŸš€ğŸš€ (Fastest) | ğŸš€ (Slow) | ğŸš€ğŸš€ (Fast after load) | ğŸš€ğŸš€ğŸš€ (Fast + Updatable) |
| SEO | âœ… Best | âœ… Good | âŒ Bad | âœ… Good |
| Data Freshness | âŒ Stale | âœ… Always Fresh | âœ… Always Fresh | âœ… Updated in intervals |
| Use Case | Blogs, Landing Pages | Dashboards, User-specific Content | Interactive Apps | News, E-commerce |

---

ğŸ”¹ Conclusion
 1.Use CSR for highly interactive apps where SEO doesnâ€™t matter (e.g., admin panels, dashboards).
 2.Use SSG for static pages with content that doesnâ€™t change often (e.g., blogs, landing pages).
 3.Use SSR for pages that need real-time data on each request (e.g., user dashboards).
 4.Use ISR to get the best of both SSG & SSR (pre-rendered but updated automatically).





--------------------------------------------------------------------------------
## **ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜-ğ—¦ğ—¶ğ—±ğ—² ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ (ğ—–ğ—¦ğ—¥) ğ˜ƒğ˜€ ğ—£ğ—¿ğ—²-ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ (ğ—¦ğ—¦ğ—š & ğ—¦ğ—¦ğ—¥) ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€** ğŸš€  

Both **Client-Side Rendering (CSR)** and **Pre-Rendering (SSG & SSR)** are rendering techniques in Next.js, but they work differently in terms of performance, SEO, and when the content is loaded.  

---

## **ğŸ­ï¸âƒ£ ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜-ğ—¦ğ—¶ğ—±ğ—² ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ (ğ—–ğ—¦ğ—¥)**
**CSR means the page is rendered in the browser (client-side) after the initial page load.** The HTML returned by the server is minimal, and React takes over to render content dynamically.

### **ğŸ”¹ How It Works:**
1. The browser **downloads a basic HTML shell** (with minimal content).  
2. React takes over and fetches the required data **via JavaScript (useEffect, API calls, etc.)**.  
3. The page is rendered dynamically **after the data is loaded**.  

### **âœ… Advantages of CSR**
âœ”ï¸ Fast subsequent page navigation (since everything is managed client-side).  
âœ”ï¸ Good for highly interactive applications like dashboards, social feeds, or chat apps.  
âœ”ï¸ Reduced load on the server since most work is done on the client.  

### **âŒ Disadvantages of CSR**
âŒ Initial page load is slow since the user sees a blank screen until JavaScript loads.  
âŒ **Bad for SEO** because search engines may not wait for JavaScript to execute.  
âŒ Requires more **JavaScript** to run in the browser, affecting performance.  

### **ğŸ”¹ Example of CSR in Next.js**
```javascript
import { useState, useEffect } from 'react';

export default function Page() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://api.example.com/data')
      .then((res) => res.json())
      .then((data) => setData(data));
  }, []);

  return <div>{data ? data.title : 'Loading...'}</div>;
}
```
ğŸ“Œ **The page initially loads without data, then fetches and renders it on the client-side.**  

---

## **ğŸ®ï¸âƒ£ ğ—£ğ—¿ğ—²-ğ—¥ğ—²ğ—»ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ (ğ—¦ğ—¦ğ—š & ğ—¦ğ—¦ğ—¥)**
**Pre-Rendering means Next.js generates the HTML for a page before sending it to the browser.** This improves performance and SEO since users receive a fully-formed HTML page.

Pre-Rendering has **two types**:  
1. **Static Generation (SSG) â€“ Page is built at build time**  
2. **Server-Side Rendering (SSR) â€“ Page is built at request time**  

---

### **ğŸ”¹ Static Site Generation (SSG)**
**SSG generates the page at build time and serves a static HTML file for every request.**  
This is the fastest and best for SEO.  

#### âœ… **Advantages of SSG**
âœ”ï¸ **Best performance** (Pre-built pages load instantly).  
âœ”ï¸ **Great for SEO** since search engines see full HTML.  
âœ”ï¸ Can use caching/CDN for super-fast delivery.  

#### âŒ **Disadvantages of SSG**
âŒ Not good for dynamic content that changes frequently (since pages are built at deploy time).  
âŒ Requires a full rebuild to update content.  

#### **ğŸ”¹ Example of SSG**
```javascript
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data.title}</div>;
}
```
ğŸ“Œ **This page is generated once during the build and served as a static file.**  

---

### **ğŸ”¹ Server-Side Rendering (SSR)**
**SSR generates the page on every request, ensuring fresh data each time.**  
Itâ€™s useful for **real-time data** like dashboards, stock prices, or user profiles.

#### âœ… **Advantages of SSR**
âœ”ï¸ **Always fresh data** (fetched at the time of request).  
âœ”ï¸ **Good for SEO** (since search engines see full HTML).  

#### âŒ **Disadvantages of SSR**
âŒ **Slower than SSG** because pages are generated on every request.  
âŒ **Higher server load** (since it runs a function for every request).  

#### **ğŸ”¹ Example of SSR**
```javascript
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data.title}</div>;
}
```
ğŸ“Œ **The page is generated dynamically for every request.**  

---

## **ğŸš€ CSR vs Pre-Rendering: Key Differences**
| Feature | **Client-Side Rendering (CSR)** | **Static Generation (SSG)** | **Server-Side Rendering (SSR)** |
|---------|--------------------------------|-----------------------------|-----------------------------|
| **Rendering Time** | In the browser (after page load) | At build time (before request) | At request time (on server) |
| **Performance** | ğŸš€ Good after initial load | ğŸš€ğŸš€ğŸš€ Best (Pre-rendered) | ğŸš€ğŸš€ Medium (Generated per request) |
| **SEO** | âŒ Bad (Search engines may not execute JavaScript) | âœ… Best (Full HTML available) | âœ… Good (Full HTML available) |
| **Data Freshness** | âœ… Always Fresh | âŒ Stale (until rebuild) | âœ… Always Fresh |
| **Use Case** | Dashboards, Single Page Apps (SPAs) | Blogs, Marketing Pages, E-commerce | Real-time data, User-specific content |

---

## **ğŸŒŸ When to Use What?**
| Scenario | Best Rendering Method |
|----------|---------------------|
| Blog, Static Pages | âœ… SSG (Fast + SEO) |
| Dashboard, User Profiles | âœ… SSR (Fresh Data) |
| Real-time updates (Chat, Live Prices) | âœ… CSR (Fast Interaction) |
| E-commerce (Products) | âœ… ISR (SSG + Automatic Updates) |

---

## **ğŸ”¹ Conclusion**
- **Use CSR** for highly interactive apps where SEO doesnâ€™t matter (e.g., admin panels, dashboards).
- **Use SSG** for static pages with content that doesnâ€™t change often (e.g., blogs, landing pages).
- **Use SSR** for pages that need real-time data on each request (e.g., user dashboards).
- **Use ISR** to get the best of both SSG & SSR (pre-rendered but updated automatically).




-----------------------------------------------------------------------------------------------------------------------------------
#### ğ—™ğ—˜ğ—§ğ—–ğ—› ğ——ğ—”ğ—§ğ—” ğ—™ğ—¿ğ—¼ğ—º ğ—”ğ—£ğ—œ  ğ—œğ—» ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜ ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜:


A page is UI that is rendered on a specific route. To create a page, add a page file inside the app directory and default export a React component. For example, to create an index page (/):

##Creating a layout
A layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.

You can define a layout by default exporting a React component from a layout file. The component should accept a children prop which can be a page or another layout.

For example, to create a layout that accepts your index page as child, add a layout file inside the app directory:
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        {/* Layout UI */}
        {/* Place children where you want to render a page or nested layout */}
        <main>{children}</main>
      </body>
    </html>
  )
}

Note:
The layout above is called a root layout because it's defined at the root of the app directory.
The root layout is required and must contain html and body tags.


-------------------------------------------------

## **ğ‘ªğ’ğ’Šğ’†ğ’ğ’• ğ‘ªğ’ğ’ğ’‘ğ’ğ’ğ’†ğ’ğ’• ğ‘°ğ’ğ’”ğ’Šğ’…ğ’† ğ’‚ ğ‘ºğ’†ğ’“ğ’—ğ’†ğ’“ ğ‘ªğ’ğ’ğ’‘ğ’ğ’ğ’†ğ’ğ’• ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”** ğŸš€  

### **ğŸ”¹ Understanding Server & Client Components**  
In **Next.js**, components are **Server Components by default**. However, if you need to use **state, hooks, or event handlers (like `onClick`)**, you must use a **Client Component**.  

Since **Client Components cannot be used directly inside Server Components**, we need to **separate them** and then import them inside the Server Component.

---

## **ğŸ­ï¸âƒ£ ğ—ªğ—µğ˜† ğ——ğ—¼ ğ—ªğ—² ğ—¡ğ—²ğ—²ğ—± ğ—® ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜ ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜?**
Server Components **cannot use:**
âŒ React Hooks (`useState`, `useEffect`)  
âŒ `onClick` or any event handlers  
âŒ Browser APIs (`localStorage`, `window`, `document`)  

Client Components **can use:**  
âœ… `useState`, `useEffect`, `useContext`  
âœ… `onClick`, `onChange`, and other events  
âœ… Interact with the browser (DOM, `localStorage`)  

---

## **2ï¸âƒ£ ğ‘¯ğ’ğ’˜ ğ’•ğ’ ğ‘¼ğ’”ğ’† ğ’‚ ğ‘ªğ’ğ’Šğ’†ğ’ğ’• ğ‘ªğ’ğ’ğ’‘ğ’ğ’ğ’†ğ’ğ’• ğ‘°ğ’ğ’”ğ’Šğ’…ğ’† ğ’‚ ğ‘ºğ’†ğ’“ğ’—ğ’†ğ’“ ğ‘ªğ’ğ’ğ’‘ğ’ğ’ğ’†ğ’ğ’•?**

### **âœ… Step 1: Create a Client Component**
In a separate file (e.g., `Counter.js`), add this:  
```javascript
"use client"; // ğŸ‘ˆ This makes it a Client Component
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>Counter: {count}</h2>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

ğŸ“Œ **ğ‘¾ğ’‰ğ’š `"ğ’–ğ’”ğ’† ğ’„ğ’ğ’Šğ’†ğ’ğ’•";`?**  
It tells Next.js that this file should be treated as a **Client Component**.

---

### **âœ… Step 2: Import the Client Component in a Server Component**
Now, import and use the `Counter` component inside a **Server Component** (e.g., `page.js`):  
```javascript
import Counter from "./Counter"; // Import Client Component

export default async function HomePage() {
  return (
    <div>
      <h1>Server Component with a Client Component</h1>
      <Counter /> {/* âœ… Using a Client Component */}
    </div>
  );
}
```
ğŸ“Œ **The `Counter` component remains interactive** while the **parent component (HomePage) is still a Server Component**.

---

## **3ï¸âƒ£ Can We Use Server Components Inside Client Components?**
âœ… **Yes!** A Client Component **can import and use Server Components**.  
âœ… This is useful when you need dynamic behavior but still want to fetch data on the server.  

### **ğŸ”¹ Example**
```javascript
import ServerData from "./ServerData"; // Server Component

export default function ClientWrapper() {
  return (
    <div>
      <h1>This is a Client Component</h1>
      <ServerData /> {/* âœ… Using a Server Component inside a Client Component */}
    </div>
  );
}
```

---

## **ğŸ°ï¸âƒ£ ğ—•ğ—²ğ˜€ğ˜ ğ—£ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ—°ğ—²ğ˜€ ğ—³ğ—¼ğ—¿ ğ—¦ğ—²ğ—¿ğ˜ƒğ—²ğ—¿ & ğ—–ğ—¹ğ—¶ğ—²ğ—»ğ˜ ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜ğ˜€**
| Feature | **Server Component** | **Client Component** |
|---------|---------------------|---------------------|
| Data Fetching | âœ… Best for fetching from APIs, databases | âŒ Should not fetch data |
| React Hooks (`useState`, `useEffect`) | âŒ Not allowed | âœ… Allowed |
| Event Handlers (`onClick`, `onChange`) | âŒ Not allowed | âœ… Allowed |
| Performance | ğŸš€ Faster, less JavaScript | âŒ More JavaScript, affects performance |
| When to Use? | Rendering static/dynamic content | Interactive elements (buttons, forms, modals) |

---

## **ğŸ±ï¸âƒ£ ğ—ğ—²ğ˜† ğ—§ğ—®ğ—¸ğ—²ğ—®ğ˜„ğ—®ğ˜†ğ˜€**
âœ… **Server Components** are default in Next.js and **do not support interactivity**.  
âœ… **Client Components** allow interactivity but **must be declared using `"use client"`**.  
âœ… **Best practice** is to keep most components **server-side** and only use Client Components where necessary.  



---------------------------------------------------------------------------------------------------------------------------------------------------------------
###ğ—–ğ—¦ğ—¦ ğ— ğ—¼ğ—±ğ˜‚ğ—¹ğ—²ğ˜€ ğ—ªğ—¶ğ˜ğ—µ ğ—¡ğ—˜ğ—«ğ—§ğ—ğ—¦:


### **1ï¸âƒ£ What is a CSS Module in Next.js?**
A **CSS Module** in Next.js is a **scoped CSS file** where styles are applied **only to a specific component** instead of affecting the entire application.  

âœ… **Automatically scoped** (No class name conflicts)  
âœ… **Works only inside the component where it's imported**  
âœ… **Best for component-based styling**  

---
## **ğ—–ğ—¦ğ—¦ ğ— ğ—¼ğ—±ğ˜‚ğ—¹ğ—²ğ˜€ ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€ ğ˜ƒğ˜€ ğ—¡ğ—¼ğ—¿ğ—ºğ—®ğ—¹ ğ—–ğ—¦ğ—¦ ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€**  

### **2ï¸âƒ£ Difference Between CSS Modules & Normal CSS in Next.js**
| Feature | **CSS Module (`.module.css`)** | **Normal CSS (`.css`)** |
|---------|------------------------------|-------------------------|
| **Scope** | Local (Only applies to imported component) | Global (Affects entire project) |
| **Class Name Conflicts** | No conflicts (Scoped styles) | Possible conflicts (Global scope) |
| **Performance** | Better (Only loads styles needed) | May load unused styles |
| **Usage** | Best for component-specific styles | Best for global styles (e.g., Reset, Layout) |
| **Syntax** | `import styles from './file.module.css'` | `import './global.css'` |

---

### **3ï¸âƒ£ ğ‘¯ğ’ğ’˜ ğ’•ğ’ ğ‘¼ğ’”ğ’† ğ‘ªğ‘ºğ‘º ğ‘´ğ’ğ’…ğ’–ğ’ğ’†ğ’” ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”?**
#### **âœ… Step 1: Create a CSS Module File**
Create a file like **`styles/Button.module.css`**:  
```css
/* styles/Button.module.css */
.button {
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  cursor: pointer;
}
```

#### **âœ… Step 2: Import and Use It in a Component**
Now, use it inside a **React Component**:  
```javascript
import styles from '../styles/Button.module.css'; // Import the module

export default function Button() {
  return <button className={styles.button}>Click Me</button>;
}
```
ğŸ“Œ **Notice:** We access styles as an object (`styles.button`) instead of just `"button"`.

---

### **4ï¸âƒ£ ğ‘¯ğ’ğ’˜ ğ’•ğ’ ğ‘¼ğ’”ğ’† ğ‘®ğ’ğ’ğ’ƒğ’‚ğ’ ğ‘ªğ‘ºğ‘º ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”?**
If you want to use normal **global CSS**, create a file like **`styles/globals.css`** and import it in `_app.js`:  
```css
/* styles/globals.css */
body {
  font-family: Arial, sans-serif;
  background-color: #f4f4f4;
}
```
Then, import it inside `_app.js` (or `layout.js` in Next.js 13+):
```javascript
import '../styles/globals.css';

export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
```

---

### **5ï¸âƒ£ ğ‘ªğ’‚ğ’ ğ’€ğ’ğ’– ğ‘¼ğ’”ğ’† ğ‘©ğ’ğ’•ğ’‰ ğ‘ªğ‘ºğ‘º ğ‘´ğ’ğ’…ğ’–ğ’ğ’†ğ’” & ğ‘µğ’ğ’“ğ’ğ’‚ğ’ ğ‘ªğ‘ºğ‘º ğ’Šğ’ ğ‘¶ğ’ğ’† ğ‘·ğ’“ğ’ğ’‹ğ’†ğ’„ğ’•?**
âœ… **Yes!**  
- **Use Global CSS (`globals.css`)** for site-wide styles like layout, typography, and resets.  
- **Use CSS Modules (`.module.css`)** for component-specific styles to avoid conflicts.  

---

### **6ï¸âƒ£ ğ‘²ğ’†ğ’š ğ‘»ğ’‚ğ’Œğ’†ğ’‚ğ’˜ğ’‚ğ’šğ’”**
ğŸ”¹ **CSS Modules** are local and scoped to specific components (Best for modular styling).  
ğŸ”¹ **Normal CSS** applies styles globally (Best for global styles like layout and resets).  
ğŸ”¹ **Using CSS Modules prevents class name conflicts** and improves **performance**.  

---------
##ğ˜¾ğ™¤ğ™£ğ™™ğ™ğ™©ğ™ğ™¤ğ™£ğ™–ğ™¡ ğ˜¾ğ™ğ™ ğ™ˆğ™¤ğ™™ğ™ªğ™¡ğ™šğ™¨ ğ™ğ™£ ğ™‰ğ™šğ™­ğ™©.ğ™Ÿğ™¨ ğŸš€
In Next.js, CSS Modules allow you to write scoped styles without affecting other components. 
You can also apply conditional CSS classes based on state or props.

âœ… 3ï¸âƒ£ ğ‘¨ğ’‘ğ’‘ğ’ğ’šğ’Šğ’ğ’ˆ ğ‘ªğ‘ºğ‘º ğ‘ªğ’ğ’ğ’…ğ’Šğ’•ğ’Šğ’ğ’ğ’‚ğ’ğ’ğ’š ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”
	ğŸ“Œ Use CSS Module in a React component:

	import { useState } from "react";
	import styles from "@/styles/Button.module.css"; // Importing the CSS module

	export default function ConditionalButton() {
	  const [isActive, setIsActive] = useState(false);

	  return (
		<button
		  className={`${styles.button} ${isActive ? styles.active : styles.inactive}`}
		  onClick={() => setIsActive(!isActive)}
		>
		  {isActive ? "Active" : "Inactive"}
		</button>
	  );
	}
 =>ğŸ”¹ How It Works:
		1.The base class styles.button is always applied.
		2.If isActive = true, styles.active is applied (button turns green).
		3.If isActive = false, styles.inactive is applied (button turns red).
		4.Button text toggles between "Active" and "Inactive" on click.


-------------------------------------------------------------------------------------------------------------------------------------------------
## **ğŸš€ ğ—œğ—ºğ—®ğ—´ğ—² ğ—¢ğ—½ğ˜ğ—¶ğ—ºğ—¶ğ˜‡ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€ (ğ—»ğ—²ğ˜…ğ˜/ğ—¶ğ—ºğ—®ğ—´ğ—²)**
Next.js provides **automatic image optimization** using the `<Image>` component from `next/image`. It improves performance by:
- **Lazy loading** images.
- **Serving responsive images** (adjusts size based on device).
- **Automatically optimizing formats** (WebP, AVIF, etc.).
- **Caching** and reducing unnecessary downloads.

---

## **âœ… 1ï¸âƒ£ Install Required Package (If Not Installed)**
Next.js **already includes `next/image`**, but if missing, install it manually:

---

## **âœ… 2ï¸âƒ£ Basic Usage of `<Image>` in Next.js**
ğŸ“Œ **Import and use the `<Image>` component:**
```jsx
import Image from "next/image";
import profilePic from "@/public/profile.jpg"; // Importing a local image

export default function Home() {
  return (
    <div>
      <h1>Next.js Image Optimization</h1>
      <Image
        src={profilePic}   // Path to the image
        alt="Profile Picture"
        width={300}        // Set fixed width
        height={300}       // Set fixed height
        priority           // Loads image without lazy loading
      />
    </div>
  );
}
```

ğŸ”¹ **ğ™’ğ’‰ğ™® ğ™ªğ’”ğ™š `<ğ™„ğ’ğ™–ğ’ˆğ™š>` ğ™ğ’ğ™¨ğ’•ğ™šğ’‚ğ™™ ğ™¤ğ’‡ `<ğ’Šğ™¢ğ’ˆ>`?**
- It **automatically optimizes** images for different screen sizes.
- **Faster loading** due to built-in lazy loading.
- Supports **modern image formats** (like WebP) automatically.

---

## **âœ… 3ï¸âƒ£ ğ™ğ’”ğ™ğ’ğ™œ ğ™ğ’†ğ™¢ğ’ğ™©ğ’† (ğ™€ğ’™ğ™©ğ’†ğ™§ğ’ğ™–ğ’) ğ™„ğ’ğ™–ğ’ˆğ™šğ’”**
For images hosted externally (e.g., from a CDN), you **must allow domains in `next.config.js`**:

ğŸ“Œ **Modify `next.config.js`:**
```js
module.exports = {
  images: {
    domains: ["example.com", "cdn.example.com"], // Allow specific external domains
  },
};
```
ğŸ“Œ **Use in a component:**
```jsx
<Image
  src="https://example.com/image.jpg"
  alt="Remote Image"
  width={400}
  height={300}
  loader={({ src }) => src} // Optional: Custom loader for CDNs
/>
```
ğŸ”¹ **ğ™’ğ’‰ğ™® ğ™˜ğ’ğ™£ğ’‡ğ™ğ’ˆğ™ªğ’“ğ™š `ğ’ğ™šğ’™ğ™©.ğ™˜ğ’ğ™£ğ’‡ğ™ğ’ˆ.ğ’‹ğ™¨`?**
- Next.js blocks unknown external images for **security** and **performance reasons**.

---

## **âœ… 4ï¸âƒ£ ğ™ğ™šğ™¨ğ™¥ğ™¤ğ™£ğ™¨ğ™ğ™«ğ™š ğ™„ğ™¢ğ™–ğ™œğ™šğ™¨ (ğ˜¼ğ™ªğ™©ğ™¤ğ™¢ğ™–ğ™©ğ™ğ™˜ ğ™ğ™ğ™¯ğ™š ğ˜¼ğ™™ğ™Ÿğ™ªğ™¨ğ™©ğ™¢ğ™šğ™£ğ™©ğ™¨)**
ğŸ“Œ **Use `fill` to make images responsive:**
```jsx
<div style={{ position: "relative", width: "100%", height: "400px" }}>
  <Image
    src="/banner.jpg"
    alt="Banner"
    fill  // Makes the image cover the entire div
    style={{ objectFit: "cover" }} // Controls how the image fits
  />
</div>
```
ğŸ”¹ **Why use `fill`?**
- The image **automatically scales** to fit the container.
- **No need to manually set width & height**.

---

## **âœ… 5ï¸âƒ£ Dynamic Images (From API)**
If you **don't know the image URL in advance** (e.g., from an API), use a **dynamic `src`**:

```jsx
export default function Product({ product }) {
  return (
    <Image
      src={product.imageUrl} // Dynamic image URL
      alt={product.name}
      width={200}
      height={200}
      unoptimized // Disable optimization if needed
    />
  );
}
```
ğŸ”¹ **Why use `unoptimized`?**
- For images **already optimized** (e.g., from a CDN like Cloudinary).

---

## **âœ… 6ï¸âƒ£ Blur Placeholder (For Better UX)**
ğŸ“Œ **Show a blurred version while loading:**
```jsx
<Image
  src="/profile.jpg"
  alt="Blur Example"
  width={300}
  height={300}
  placeholder="blur" // Enable blur effect
  blurDataURL="data:image/png;base64,..." // Custom blur image (optional)
/>
```
ğŸ”¹ **Why use blur placeholders?**
- **Smooth loading experience** (no flickering).
- Useful for **large images**.

---

## **âœ… 7ï¸âƒ£ Next.js Image Loader (For Custom Optimization)**
You can define a **custom image loader** (useful for Cloudinary, Imgix, etc.).

ğŸ“Œ **Example: Using Cloudinary**
```js
const cloudinaryLoader = ({ src, width, quality }) => {
  return `https://res.cloudinary.com/demo/image/upload/w_${width},q_${quality || 75}/${src}`;
};

<Image
  loader={cloudinaryLoader}
  src="my-image.jpg"
  alt="Cloudinary Optimized Image"
  width={400}
  height={300}
/>
```
ğŸ”¹ **Why use a custom loader?**
- Integrates **custom image CDNs** for better performance.

---

## **ğŸ”¥ ğ‘ºğ’–ğ’ğ’ğ’‚ğ’“ğ’š**
âœ… **Use `<Image>` instead of `<img>`** for **automatic optimization**.  
âœ… **Allow external images** in `next.config.js`.  
âœ… **Use `fill`** for **responsive images**.  
âœ… **Use `blur` placeholder** for smooth loading.  
âœ… **Use a custom loader** for external CDNs (Cloudinary, Imgix, etc.).  

--------------------------------------------------------------------------------------------------------------------------

# ğŸš€ **ğ—™ğ—¼ğ—»ğ˜ ğ—¢ğ—½ğ˜ğ—¶ğ—ºğ—¶ğ˜‡ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€** 
 
	1.Next.js provides **automatic font optimization** to improve performance by reducing layout shifts and loading times. 
	2.You can optimize fonts using **Google Fonts, local fonts, or custom fonts**.
	3.If we use the normal fonts then each time we load the site ,the server gets the request from where we to load the fonts ,
	4.But if we use the Next JS font feature then it place the font in cache and don't send the request to server each we load the site which ultimatey increase the speed of our site.
	
---

## âœ… **1ï¸âƒ£ ğ‘¼ğ’”ğ’Šğ’ğ’ˆ ğ‘®ğ’ğ’ğ’ˆğ’ğ’† ğ‘­ğ’ğ’ğ’•ğ’” ğ’˜ğ’Šğ’•ğ’‰ `ğ’ğ’†ğ’™ğ’•/ğ’‡ğ’ğ’ğ’•/ğ’ˆğ’ğ’ğ’ˆğ’ğ’†` (ğ‘©ğ’†ğ’”ğ’• ğ‘·ğ’†ğ’“ğ’‡ğ’ğ’“ğ’ğ’‚ğ’ğ’„ğ’†)**

Next.js **fetches, hosts, and optimizes** Google Fonts automatically.  

### ğŸ“Œ **Example: Importing Google Fonts in Next.js**  
```jsx
import { Inter } from "next/font/google";

const inter = Inter({
  subsets: ["latin"], // Define character subsets
  weight: ["400", "700"], // Choose font weights
  variable: "--font-inter", // Define a CSS variable
});

export default function Home() {
  return (
    <div className={inter.className}>
      <h1>Optimized Google Fonts in Next.js</h1>
    </div>
  );
}
```
### ğŸ”¹ **Why use `next/font/google`?**
âœ… **Faster** than `<link>` in `_app.js`  
âœ… **Removes unused font styles**  
âœ… **Self-hosted, no external requests**  
âœ… **No Flash of Unstyled Text (FOUT)**  

---

## âœ… **2ï¸âƒ£ ğ‘¼ğ’”ğ’Šğ’ğ’ˆ ğ‘³ğ’ğ’„ğ’‚ğ’ ğ‘­ğ’ğ’ğ’•ğ’” ğ’˜ğ’Šğ’•ğ’‰ `ğ’ğ’†ğ’™ğ’•/ğ’‡ğ’ğ’ğ’•/ğ’ğ’ğ’„ğ’‚ğ’`**
For custom fonts stored in your project.

### ğŸ“Œ **Example: Using a Local Font**
```jsx
import localFont from "next/font/local";

const myFont = localFont({
  src: "../public/fonts/MyCustomFont.woff2",
  display: "swap", // Avoid layout shifts
});

export default function Home() {
  return (
    <div className={myFont.className}>
      <h1>Custom Local Font in Next.js</h1>
    </div>
  );
}
```
### ğŸ”¹ **ğ‘¾ğ’‰ğ’š ğ’–ğ’”ğ’† `ğ’ğ’†ğ’™ğ’•/ğ’‡ğ’ğ’ğ’•/ğ’ğ’ğ’„ğ’‚ğ’`?**
âœ… **Great for branding** (custom fonts)  
âœ… **No external requests**  
âœ… **Optimized loading**  

---


## âœ… **3ï¸âƒ£ ğ‘¼ğ’”ğ’Šğ’ğ’ˆ ğ‘®ğ’ğ’ğ’ˆğ’ğ’† ğ‘­ğ’ğ’ğ’•ğ’” ğ’˜ğ’Šğ’•ğ’‰ `_ğ’‚ğ’‘ğ’‘.ğ’‹ğ’”` (ğ‘¶ğ’ğ’… ğ‘´ğ’†ğ’•ğ’‰ğ’ğ’… - ğ‘µğ’ğ’• ğ‘¹ğ’†ğ’„ğ’ğ’ğ’ğ’†ğ’ğ’…ğ’†ğ’…)**

You can still use Google Fonts the **traditional way** by adding a `<link>` tag inside `_app.js`, but this is **less optimized** than `next/font/google`.

### ğŸ“Œ **Example: Adding Fonts in `_app.js`**
```jsx
import Head from "next/head";

export default function MyApp({ Component, pageProps }) {
  return (
    <>
      <Head>
        <link
          rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
        />
      </Head>
      <Component {...pageProps} />
    </>
  );
}
```
### ğŸ”¹ **ğ—ªğ—µğ˜† ğ—¶ğ˜€ ğ˜ğ—µğ—¶ğ˜€ ğ—»ğ—¼ğ˜ ğ—¿ğ—²ğ—°ğ—¼ğ—ºğ—ºğ—²ğ—»ğ—±ğ—²ğ—±?**
âŒ **Slower** (fetches fonts externally)  
âŒ **No font-subset optimization**  
âŒ **May cause layout shifts (FOIT/FOUT)**  

---

## âœ… **ğŸ’ï¸âƒ£ ğ€ğ©ğ©ğ¥ğ²ğ¢ğ§ğ  ğ…ğ¨ğ§ğ­ğ¬ ğ¢ğ§ ğ†ğ¥ğ¨ğ›ğšğ¥ ğ‚ğ’ğ’**
If you're using **CSS Modules** or a global CSS file, define fonts in `globals.css`:

### ğŸ“Œ **Example: Applying Google Fonts in CSS**
```css
@import url("https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap");

body {
  font-family: "Roboto", sans-serif;
}
```
**âš ï¸ This method is also not optimized!** Use `next/font/google` instead.

---

## ğŸ¯ **ğ—ªğ—µğ—¶ğ—°ğ—µ ğ— ğ—²ğ˜ğ—µğ—¼ğ—± ğ—¦ğ—µğ—¼ğ˜‚ğ—¹ğ—± ğ—¬ğ—¼ğ˜‚ ğ—¨ğ˜€ğ—²?**
| Method                | Performance | Ease of Use | Recommended? |
|----------------------|-------------|------------|-------------|
| `next/font/google`  | âœ… âœ… âœ… **Best** | âœ… Easy | âœ… Yes |
| `next/font/local`   | âœ… âœ… âœ… **Best for branding** | âœ… Easy | âœ… Yes |
| `_app.js` `<link>`  | âŒ Slower  | âœ… Easy | âŒ No |
| `@import` in CSS    | âŒ Slowest  | âœ… Easy | âŒ No |






Note:
1. ğŸ“Œ Why Use className={roboto.className} in Next.js Fonts?
Next.js provides automatic font optimization when using next/font/google. Instead of loading fonts via an external CDN (like in normal HTML/CSS), Next.js downloads and hosts the font locally for better performance and removes unnecessary font variations to reduce page load time.

 1ï¸âƒ£ Import the Font Using next/font/google
	In Next.js 13+ with App Router (app/), you import fonts like this:

	import { Roboto } from "next/font/google";

	const roboto = Roboto({
	  subsets: ["latin"], // Optimized for Latin characters
	  weight: "400", // Choose specific weights
	});
	ğŸ”¹ This downloads the Google Font and optimizes it at build time.

2. âœ… Using roboto.className ensures:

	->Automatic optimization (loads only the needed font styles).
	->Reduced CLS (Cumulative Layout Shift) â€“ The page wonâ€™t shift while loading fonts.
	-Local hosting of fonts instead of fetching from Google every time.



-----------------------------------------------------------------------------------------------------------------------------------------------------------

### **ğŸ“Œ ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ— ğ—²ğ˜ğ—®ğ—±ğ—®ğ˜ğ—® ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€?** 
 
**Metadata** refers to **information about a webpage** that helps browsers, search engines, and social media platforms understand its content. It includes:  
âœ… **Title** (`<title>`) â€“ The page title displayed in the browser tab.  
âœ… **Description** (`<meta name="description">`) â€“ A short summary shown in search results.  
âœ… **Keywords** (`<meta name="keywords">`) â€“ Words that help search engines index your page.  
âœ… **OG Tags** (`og:title`, `og:image`, etc.) â€“ Used for social media previews.  

---

 ## **ğŸ“Œ ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ’—ğ’” ğ‘«ğ’šğ’ğ’‚ğ’ğ’Šğ’„ ğ‘´ğ’†ğ’•ğ’‚ğ’…ğ’‚ğ’•ğ’‚**  :
 
### **âœ… ğ—¦ğ˜ğ—®ğ˜ğ—¶ğ—° ğ— ğ—²ğ˜ğ—®ğ—±ğ—®ğ˜ğ—®**  
When the metadata is the same for **every page**, it's called **static metadata**.  
Example:  
```jsx
export const metadata = {
  title: "My Next.js App",
  description: "This is a static page with fixed metadata.",
};
```
**ğŸ”¹ Use Case:** A homepage or an About page with fixed content.  

---

### **âœ… ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ— ğ—²ğ˜ğ—®ğ—±ğ—®ğ˜ğ—®**  
When the metadata **changes based on the page content**, it's called **dynamic metadata**.  
For example, in a blog website, each blog post has a different title and description.

#### **ğŸ“Œ How to Generate Dynamic Metadata?**  
In **Next.js 13+ (App Router)**, you can use an **async function** to dynamically fetch metadata.

```jsx
export async function generateMetadata({ params }) {
  // Fetch data from API or database
  const post = await fetch(`https://dummyjson.com/posts/${params.id}`).then((res) => res.json());

  return {
    title: post.title,
    description: post.body,
  };
}

export default function BlogPost({ params }) {
  return <h1>Blog Post {params.id}</h1>;
}
```
ğŸ”¹ Here, **metadata updates dynamically** based on the post ID.  
ğŸ”¹ The function **fetches the data** and returns a title & description **for each post**.

---

## **ğŸ“Œ ğ— ğ—²ğ˜ğ—®ğ—±ğ—®ğ˜ğ—® ğ—¶ğ—» `ğ—»ğ—²ğ˜…ğ˜/ğ—µğ—²ğ—®ğ—±` (ğ—™ğ—¼ğ—¿ ğ—£ğ—®ğ—´ğ—²ğ˜€ ğ—¥ğ—¼ğ˜‚ğ˜ğ—²ğ—¿)**

If you're using the **old "Pages Router" (`pages/`)**, you can manually add metadata using `next/head`:
```jsx
import Head from "next/head";

export default function Blog({ post }) {
  return (
    <>
      <Head>
        <title>{post.title}</title>
        <meta name="description" content={post.body} />
      </Head>
      <h1>{post.title}</h1>
    </>
  );
}
```
ğŸ”¹ **This works but isnâ€™t optimized as well as the App Router's `metadata` API.**  

---

## **ğŸ“Œ ğ’ğ„ğ ğğğ¬ğ­ ğğ«ğšğœğ­ğ¢ğœğğ¬ ğŸğ¨ğ« ğŒğğ­ğšğğšğ­ğš**

âœ” **Use clear and unique titles & descriptions** for each page.  
âœ” **Keep titles under 60 characters** and descriptions under **160 characters**.  
âœ” **Use Open Graph (`og:`) and Twitter (`twitter:`) meta tags** for social media sharing.  

---

## **ğŸš€ Conclusion**
âœ… **Static Metadata** â€“ Used when the same metadata applies to all pages.  
âœ… **Dynamic Metadata** â€“ Generated based on API data or route params (e.g., blog posts).  
âœ… **Next.js 13+ (App Router)** provides an easy way to generate metadata dynamically using `generateMetadata()`.  

---------------------------------------------------------------------------------------------------------------------------------------------------------------
### ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ ğ—–ğ—¼ğ—ºğ—½ğ—¼ğ—»ğ—²ğ—»ğ˜ ğ—œğ—» ğ—¡ğ—˜ğ—«ğ—§ ğ—ğ—¦:

In **Next.js**, the `next/script` component is used for loading external scripts efficiently. It helps with **lazy loading**, **priority management**, and **performance optimization**.  

---

## **ğ—›ğ—¼ğ˜„ ğ˜ğ—¼ ğ—¨ğ˜€ğ—² `<ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜>` ğ—¶ğ—» ğ—¡ğ—²ğ˜…ğ˜.ğ—·ğ˜€**
First, import the `Script` component:  

```jsx
import Script from "next/script";
```

### **1. Adding an External Script**
```jsx
import Script from "next/script";

export default function Home() {
  return (
    <div>
      <h1>Next.js Script Component Example</h1>
      
      {/* Adding an external script */}
      <Script
        src="https://example.com/script.js"
        strategy="lazyOnload"
        onLoad={() => console.log("Script loaded!")}
      />
    </div>
  );
}
```
**âœ… Explanation:**  
- `src="https://example.com/script.js"` â†’ External script URL.  
- `strategy="lazyOnload"` â†’ Loads after the page has fully loaded.  
- `onLoad={() => console.log("Script loaded!")}` â†’ Executes a function when the script loads.  

---

### **ğŸ®. ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ˜ ğ—Ÿğ—¼ğ—®ğ—±ğ—¶ğ—»ğ—´ ğ—¦ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ—¶ğ—²ğ˜€**
| **Strategy**   | **When it Loads?** | **Use Case** |
|---------------|-------------------|-------------|
| `beforeInteractive` | Loads **before page hydration** | Essential scripts like authentication SDKs. |
| `afterInteractive` | Loads **after page hydration** (default) | Analytics, tracking, non-critical scripts. |
| `lazyOnload` | Loads **after page loads fully** | Ads, chat widgets, social media embeds. |

Example:  
```jsx
<Script src="/analytics.js" strategy="beforeInteractive" />
<Script src="/chat-widget.js" strategy="afterInteractive" />
<Script src="/ads.js" strategy="lazyOnload" />
```

---

### **3. Inline Scripts in Next.js**
You can add inline scripts for custom logic:  
```jsx
<Script id="inline-script">
  {`console.log("Inline script executed!");`}
</Script>
```

---

## **ğ—ªğ—µğ—²ğ—» ğ˜ğ—¼ ğ—¨ğ˜€ğ—² `<ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜>`?**
âœ… Loading **third-party** scripts (Google Analytics, Chatbots, etc.).  
âœ… Preventing **render-blocking** by delaying script execution.  
âœ… Ensuring scripts load in the right **priority order**.  

Note:
This script component load that external js file which we laod through Script component of Next JS in that particular component only but normal html script loads in complete website.





-----------------------------------------------------------------------------------------------------------------------------------------------------------
## Loader In Next Js:
 To make  Loader make a loading.js file inside that component and if there is any data to come it automatically fist shows laoder then data will come.
 

----------------------------------------------------------
## ğ’ğ­ğšğ­ğ¢ğœ ğ€ğ¬ğ¬ğğ­ğ¬ ğˆğ§ ğğ„ğ—ğ“ğ‰ğ’:
	1.In Next.js, static assets like images, fonts, and other files should be stored in the public/ folder. This allows direct access without needing an import or special handling.
	2.All these sttaic asest don't get chnage when we make the production build as all other get minified when we make the build and thses files are not much secure .
	3.Also we keep the SEO related things here like roboto.txt,sitemal.xml,etc

1ï¸âƒ£ ğ‘¾ğ’‰ğ’†ğ’“ğ’† ğ’•ğ’ ğ‘ºğ’•ğ’ğ’“ğ’† ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘¨ğ’”ğ’”ğ’†ğ’•ğ’”?

Next.js serves all files placed inside the public/ folder at the root level of your project.

ba
/my-next-app
â”‚â”€â”€ /public
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ logo.png
â”‚   â”‚   â”œâ”€â”€ banner.jpg
â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”œâ”€â”€ robots.txt
â”‚   â”œâ”€â”€ fonts/
â”‚   â”‚   â”œâ”€â”€ custom-font.woff2
â”‚â”€â”€ /pages
â”‚â”€â”€ /components
â”‚â”€â”€ /styles
â”‚â”€â”€ next.config.js
â”‚â”€â”€ package.json

2ï¸âƒ£ Using Static Assets in Next.js
âœ… Using Images in public/
You can reference static images using absolute paths from public/.

export default function Home() {
  return (
    <div>
      <h1>Welcome to Next.js</h1>
      <img src="/images/logo.png" alt="Logo" width={200} height={100} />
    </div>
  );
}
âœ… No need to import images.
âœ… Uses absolute paths starting from /public/.
âŒ No automatic optimization (use next/image for better performance).

âœ… Using next/image for Optimized Images
Next.js provides an optimized Image component for better performance, lazy loading, and automatic resizing.

import Image from "next/image";

export default function Home() {
  return (
    <div>
      <h1>Next.js Optimized Image</h1>
      <Image 
        src="/images/logo.png" 
        alt="Logo" 
        width={200} 
        height={100} 
        priority 
      />
    </div>
  );
}
ğğ¨ğ­ğ:
âœ… Optimized for performance.
âœ… Supports lazy loading, automatic resizing, and blur-up placeholders.
âœ… Use priority for important images to load immediately.


----------------------------------------------------------------------------------------------------------------------------------------------------------

ğŸ“Œ ğ‘¾ğ’‰ğ’‚ğ’• ğ’Šğ’” ğ’‚ ğ‘©ğ’–ğ’Šğ’ğ’… ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”?
A build in Next.js refers to the process of compiling, optimizing, and bundling the application to make it production-ready. It transforms the code into a highly efficient format suitable for deployment.


ğŸ“Œ ğ–ğ¡ğšğ­ ğ¢ğ¬ ğš ğğ®ğ¢ğ¥ğ ğ¢ğ§ ğğğ±ğ­.ğ£ğ¬?
A build in Next.js refers to the process of compiling, optimizing, and bundling the application to make it production-ready. It transforms the code into a highly efficient format suitable for deployment.

ğŸš€ ğ“ğ²ğ©ğğ¬ ğ¨ğŸ ğğ®ğ¢ğ¥ğğ¬ ğ¢ğ§ ğğğ±ğ­.ğ£ğ¬
Next.js offers different types of builds based on the needs of the application:

ğŸï¸âƒ£ ğƒğğ¯ğğ¥ğ¨ğ©ğ¦ğğ§ğ­ ğğ®ğ¢ğ¥ğ (ğ§ğğ±ğ­ ğğğ¯)
	Used during development.
	Runs a local server with hot reloading.
	Fast but not optimized.
	Uses dynamic compilation, which means every request is processed in real-time.
	
	Command:
	npm run dev or  yarn dev
	
	ğŸ”¹ Use case: When actively coding and debugging.

--------------

ğŸï¸âƒ£ ğğ«ğ¨ğğ®ğœğ­ğ¢ğ¨ğ§ ğğ®ğ¢ğ¥ğ (ğ§ğğ±ğ­ ğ›ğ®ğ¢ğ¥ğ)
	Creates an optimized version of the application.
	Pre-renders pages (SSG/ISR).
	Minifies JavaScript and CSS for faster performance.
	Generates static assets and server-side rendered components.

Command: npm run build or yarn build

ğŸ”¹ Use case: Preparing the app for deployment.

--------------

3ï¸âƒ£ Static Export (next export)
Converts a Next.js app into a fully static site.
Generates HTML and CSS files for every page.
Useful for static hosting (e.g., GitHub Pages, Vercel, Netlify).

Command:npm run build
npm run export

 Use case: When hosting on a CDN or a static hosting provider.

--------------

4ï¸âƒ£ Serverless Build
Converts Next.js API routes and pages into serverless functions.
Used when deploying to Vercel, AWS Lambda, or Netlify Functions.
Command:

NEXT_PUBLIC_BUILD_TARGET=serverless npm run build

ğŸ”¹ Use case: Deploying to a serverless environment like AWS Lambda.


--------------
ğŸ’¡ ğ‡ğ¨ğ° ğ­ğ¨ ğ‚ğ«ğğšğ­ğ ğš ğğ«ğ¨ğğ®ğœğ­ğ¢ğ¨ğ§ ğğ®ğ¢ğ¥ğ ğ¢ğ§ ğğğ±ğ­.ğ£ğ¬
Step 1: Install Dependencies
Ensure that all dependencies are installed:
npm install

Step 2: Run the Build Command
npm run build
or
yarn build

Step 3: Start the Production Server
After the build, you can run:
npm run start

This starts the optimized production server.

ğŸ”¹ What Happens During next build?
	Compiles & Bundles: Next.js compiles all pages into static or server-side rendered versions.
	Minifies Code: Reduces JavaScript & CSS file sizes.
	Optimizes Images: Uses Next.js image optimization.
	Removes Unused Code: Tree-shaking eliminates unused JavaScript.



-----------------------------------------------------------------------------------------------------------------------------------------------------

### **ğŸ“Œ ğ‘¾ğ’‰ğ’‚ğ’• ğ’Šğ’” ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘¯ğ‘»ğ‘´ğ‘³ ğ’Šğ’ ğ‘µğ’†ğ’™ğ’•.ğ’‹ğ’”?**  
In **Next.js**, **Static HTML** refers to pages that are pre-generated at **build time** and served as simple `.html` files without requiring a Node.js server.
These pages are fast, efficient, and can be deployed to **CDNs (Content Delivery Networks) like Vercel, Netlify, or GitHub Pages**.

---

## **ğŸš€ ğ‡ğ¨ğ° ğ’ğ­ğšğ­ğ¢ğœ ğ‡ğ“ğŒğ‹ ğ–ğ¨ğ«ğ¤ğ¬ ğ¢ğ§ ğğğ±ğ­.ğ£ğ¬?**

Next.js automatically **exports pages as static HTML** if they meet these conditions:
1. **No `getServerSideProps()`** â†’ The page does not fetch dynamic data on each request.
2. **Uses `getStaticProps()`** â†’ The page fetches data **at build time**.
3. **No API Routes Used** â†’ API calls must be handled externally.
4. **No `useEffect()` for Fetching Data** â†’ If fetching inside `useEffect()`, it won't be included in the static build.

---

## **ğŸ”¹ ğ‡ğ¨ğ° ğ­ğ¨ ğ†ğğ§ğğ«ğšğ­ğ ğ’ğ­ğšğ­ğ¢ğœ ğ‡ğ“ğŒğ‹ ğ¢ğ§ ğğğ±ğ­.ğ£ğ¬**

There are **two ways** to create a **static HTML page** in Next.js:

### **1ï¸âƒ£ ğ·ğ‘’ğ‘“ğ‘ğ‘¢ğ‘™ğ‘¡ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘ ğ‘ƒğ‘ğ‘”ğ‘’ğ‘  (ğ‘ğ‘œ ğ·ğ‘ğ‘¡ğ‘ ğ¹ğ‘’ğ‘¡ğ‘â„ğ‘–ğ‘›ğ‘”)**
Any page without `getStaticProps` or `getServerSideProps` will automatically be **exported as static HTML**.

```jsx
// pages/about.js
export default function About() {
  return <h1>About Page (Static HTML)</h1>;
}
```
âœ… This page is **static** and will be included as a `.html` file in the output.

---

### **2ï¸âƒ£ ğ‘ˆğ‘ ğ‘–ğ‘›ğ‘” `ğ‘”ğ‘’ğ‘¡ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘ğ‘ƒğ‘Ÿğ‘œğ‘ğ‘ ()` ğ‘“ğ‘œğ‘Ÿ ğ‘ƒğ‘Ÿğ‘’-ğ‘Ÿğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿğ‘–ğ‘›ğ‘”**
If a page needs **fetched data** but can be pre-generated at **build time**, use `getStaticProps()`.

```jsx
// pages/products.js
export async function getStaticProps() {
  const res = await fetch("https://dummyjson.com/products");
  const data = await res.json();

  return {
    props: { products: data.products },
  };
}

export default function Products({ products }) {
  return (
    <div>
      <h1>Products List</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>{product.title}</li>
        ))}
      </ul>
    </div>
  );
}
```
âœ… This page **fetches product data at build time** and generates a static HTML file.

---

## **ğŸ’¡ ğ‡ğ¨ğ° ğ­ğ¨ ğ†ğğ§ğğ«ğšğ­ğ ğ’ğ­ğšğ­ğ¢ğœ ğ‡ğ“ğŒğ‹ (`ğ§ğğ±ğ­ ğğ±ğ©ğ¨ğ«ğ­`)?**

To **export all static pages as HTML**, use:

npm run build
npm run export
```
This will create a `/out` folder containing **only static files (`.html`, `.css`, `.js`)**.

---


## **ğŸ›  ğ‘¾ğ’‰ğ’†ğ’ ğ’•ğ’ ğ‘¼ğ’”ğ’† ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘¯ğ‘»ğ‘´ğ‘³?**

âœ… **Best for SEO** â†’ Google can index pre-rendered pages.  
âœ… **Faster Load Times** â†’ No backend processing on each request.  
âœ… **Works on Any Hosting** â†’ Deploy on **GitHub Pages, Netlify, or Vercel**.  
âœ… **No Need for a Server** â†’ Just a CDN is enough.  

---

## **ğŸ”¹ ğ‘¾ğ’‰ğ’†ğ’ ğ‘µğ‘¶ğ‘» ğ’•ğ’ ğ‘¼ğ’”ğ’† ğ‘ºğ’•ğ’‚ğ’•ğ’Šğ’„ ğ‘¯ğ‘»ğ‘´ğ‘³?**
âŒ If the page needs **real-time data updates**.  
âŒ If data changes **frequently** and must be updated on every request.  
âŒ If using **user-specific content** (like authentication).  

---

## **ğŸ”¥ ğ„ğ±ğšğ¦ğ©ğ¥ğ: ğ’ğ­ğšğ­ğ¢ğœ ğ¯ğ¬ ğƒğ²ğ§ğšğ¦ğ¢ğœ**

| Feature             | Static HTML (`getStaticProps`) | Dynamic (`getServerSideProps`) |
|---------------------|--------------------------------|--------------------------------|
| **Generated**       | At **build time**             | On **every request**          |
| **Performance**     | âš¡ **Very fast (CDN cached)** | ğŸ¢ Slower (Runs server-side)  |
| **Best for**        | Blogs, Landing Pages, Docs   | Dashboards, User Profiles    |

---

## **ğŸ¯ ğ‚ğ¨ğ§ğœğ¥ğ®ğ¬ğ¢ğ¨ğ§**
âœ… **Static HTML in Next.js** makes websites **blazing fast and scalable**.  
âœ… Use **`next export`** to **convert Next.js to a pure static site**.  
âœ… Works best for **blogs, landing pages, and public content**.  






-----------------------------------------------------------------------------------------------------------------------------------------------------

## ğ—¥ğ—²ğ—±ğ—¶ğ—¿ğ—²ğ—°ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—¡ ğ—¡ğ—˜ğ—«ğ—§ğ—ğ—¦:


In **Next.js**, you can handle **redirections** in multiple ways depending on whether you need **server-side**, **client-side**, or **API-based** redirects. Hereâ€™s a breakdown:

---

## **ğŸï¸âƒ£ ğ‘ğğğ¢ğ«ğğœğ­ ğ¢ğ§ `ğ§ğğ±ğ­.ğœğ¨ğ§ğŸğ¢ğ .ğ£ğ¬` (ğ’ğ­ğšğ­ğ¢ğœ ğ‘ğğğ¢ğ«ğğœğ­ğ¬)**
You can define permanent or temporary redirects at the **server level** using `next.config.js`.

ğŸ”¹ **Example: Redirect `/old-route` to `/new-route`**
```javascript
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: "/old-route",
        destination: "/new-route",
        permanent: true, // `true` sends a 308 Permanent Redirect
      },
    ];
  },
};
```
âœ… **Best for:** SEO-friendly redirects that are handled at the **server level**.

---

## **ğŸï¸âƒ£ ğ‘ğğğ¢ğ«ğğœğ­ ğ¢ğ§ `ğ ğğ­ğ’ğğ«ğ¯ğğ«ğ’ğ¢ğğğğ«ğ¨ğ©ğ¬` (ğ’ğğ«ğ¯ğğ«-ğ’ğ¢ğğ ğ‘ğğğ¢ğ«ğğœğ­)**
This method is useful when you need to check conditions **on each request**.

ğŸ”¹ **Example: Redirect based on authentication**
```javascript
export async function getServerSideProps(context) {
  const { req } = context;
  const user = req.cookies.token; // Example: Check if a user is logged in

  if (!user) {
    return {
      redirect: {
        destination: "/login",
        permanent: false, // Temporary redirect (307)
      },
    };
  }

  return { props: {} }; // Continue rendering the page if user is logged in
}
```
âœ… **Best for:** Redirecting users based on **authentication, roles, or dynamic conditions**.

---

## **ğŸ‘ï¸âƒ£ ğ‘ğğğ¢ğ«ğğœğ­ ğ¢ğ§ `ğ®ğ¬ğğ‘ğ¨ğ®ğ­ğğ«` (ğ‚ğ¥ğ¢ğğ§ğ­-ğ’ğ¢ğğ ğ‘ğğğ¢ğ«ğğœğ­)**
For redirects **inside components** (e.g., after a button click), use the **Next.js Router**.

ğŸ”¹ **Example: Redirect when a button is clicked**
```javascript
import { useRouter } from "next/router";

export default function HomePage() {
  const router = useRouter();

  const handleRedirect = () => {
    router.push("/dashboard"); // Redirect to dashboard
  };

  return <button onClick={handleRedirect}>Go to Dashboard</button>;
}
```
âœ… **Best for:** **Navigation inside components**, such as redirects after a button click.

---

## **ğŸ’ï¸âƒ£ ğ‘ğğğ¢ğ«ğğœğ­ ğ¢ğ§ ğ€ğğˆ ğ‘ğ¨ğ®ğ­ğğ¬**
If you need to handle redirects from an API, you can use `res.redirect()` in a Next.js API route.

ğŸ”¹ **Example: Redirect from an API route**
```javascript
export default function handler(req, res) {
  res.writeHead(302, { Location: "/new-route" });
  res.end();
}
```
âœ… **Best for:** Redirecting users after a form submission or an API call.

---
## **ğŸ’ï¸âƒ£ ğ‘ğğğ¢ğ«ğğœğ­ ğ¢ğ§ ğ€ğğˆ ğ‘ğ¨ğ®ğ­ğğ¬**
| **Method** | **Use Case** |
|------------|-------------|
| **next.config.js** | Best for **static, SEO-friendly redirects**. |
| **getServerSideProps** | Use when **checking conditions dynamically (authentication, permissions, etc.)**. |
| **useRouter** | For **client-side navigation (button clicks, after login, etc.)**. |
| **API Route** | Use when **handling redirects inside an API request**. |

---





import Image from "next/image";
import styles from "./page.module.css";

export default function Home() {
  return (
    <div className={styles.page}>
      <main className={styles.main}>
       <h1>Export Static HTML Page WIth Build</h1>
      </main>
    </div>
  );
}













Nesting layouts
By default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children prop. You can nest layouts by adding layout inside specific route segments (folders).

For example, to create a layout for the /blog route, add a new layout file inside the blog folder.

File hierarchy showing root layout wrapping the blog layout
app/blog/layout.tsx

export default function BlogLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).

##Creating a nested route
A nested route is a route composed of multiple URL segments. For example, the /blog/[slug] route is composed of three segments:

/ (Root Segment)
blog (Segment)
[slug] (Leaf Segment)
In Next.js:

Folders are used to define the route segments that map to URL segments.
Files (like page and layout) are used to create UI that is shown for a segment.
To create nested routes, you can nest folders inside each other. For example, to add a route for /blog, create a folder called blog in the app directory. Then, to make /blog publicly accessible, add a page file:

File hierarchy showing blog folder and a page.js file
app/blog/page.tsx
TypeScript

TypeScript

import { getPosts } from '@/lib/posts'
import { Post } from '@/ui/post'
 
export default async function Page() {
  const posts = await getPosts()
 
  return (
    <ul>
      {posts.map((post) => (
        <Post key={post.id} post={post} />
      ))}
    </ul>
  )
}
You can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new [slug] folder inside blog and add a page file:

File hierarchy showing blog folder with a nested slug folder and a page.js file
app/blog/[slug]/page.tsx
TypeScript

TypeScript

function generateStaticParams() {}
 
export default function Page() {
  return <h1>Hello, Blog Post Page!</h1>
}
Good to know: Wrapping a folder name in square brackets (e.g. [slug]) creates a special dynamic route segment used to generate multiple pages from data. This is useful for blog posts, product pages, etc.

.ves-megamenu .navigation .services-menu .right-sidebar .imageAndText-container .imageAndText-small .imageAndText-info a.widget-button {
    background-color: #D6D2C4!important;
    border: none;
    width: 205px;
    font-weight: 500 !important;
    letter-spacing: 0.64px;
    color: #575257;
}

.ves-megamenu .inspiration-container .dropdown-menu .submenu-inner .item-content > .nav-dropdown .imageAndText--left .imageAndText-container .imageAndText-small a.widget-button {
    width: 165px;
    min-width: 165px;
    color: #575257;
}

   .page-wrapper.collections div#Versailles .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections div#Chambord .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections div#Cheverny .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections div#Bardilino .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections div#Chevron .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections div#Chevron .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections div#Borders .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections .the3ComponentsSection .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections .chevronLayingPattern .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info,
    .page-wrapper.collections .OneBox16Plank .imageAndText--hasCta.imageAndText--1-image .imageAndText-container .imageAndText-info
